name: Deploy

on:
  push:
    branches:
      - main
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, pdo_mysql, zip, gd, exif, pcntl, bcmath, xml, curl

      - name: Copy .env
        run: php -r "file_exists('.env') || copy('.env.example', '.env');"

      - name: Install Dependencies
        run: composer install -q --no-ansi --no-interaction --no-scripts --no-progress --prefer-dist

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install NPM dependencies
        run: npm ci

      - name: Build assets
        run: npm run build

      - name: Generate key
        run: php artisan key:generate

      - name: Directory Permissions
        run: chmod -R 775 storage bootstrap/cache

      - name: Create Database
        run: |
          mkdir -p database
          touch database/database.sqlite

      - name: Run Migrations
        env:
          DB_CONNECTION: sqlite
          DB_DATABASE: database/database.sqlite
        run: php artisan migrate --force

      - name: Execute tests (Unit and Feature tests) via PHPUnit
        env:
          DB_CONNECTION: sqlite
          DB_DATABASE: database/database.sqlite
        run: vendor/bin/phpunit

      - name: Run Laravel Pint
        run: vendor/bin/pint --test

  build:
    needs: test
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
      - uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, pdo_mysql, zip, gd, exif, pcntl, bcmath, xml, curl

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Composer dependencies
        run: composer install --no-dev --optimize-autoloader --no-interaction

      - name: Install NPM dependencies
        run: npm ci

      - name: Build assets for production
        run: npm run build

      - name: Create deployment archive
        run: |
          # Wait for file system to sync to ensure all writes are complete
          sync
          
          # Create temporary directory for deployment package
          DEPLOY_DIR="/tmp/deploy-package"
          mkdir -p "$DEPLOY_DIR"
          
          # Copy files to temporary directory, excluding unnecessary files
          find . -mindepth 1 -maxdepth 1 \
            ! -name '.git' \
            ! -name '.github' \
            ! -name 'node_modules' \
            ! -name 'tests' \
            ! -name '.env*' \
            ! -name 'docker*' \
            ! -name 'Dockerfile' \
            ! -name '.dockerignore' \
            ! -name 'phpunit.xml' \
            ! -name '*.md' \
            ! -name 'deploy.tar.gz' \
            -exec cp -r {} "$DEPLOY_DIR/" \;
          
          # Create archive from stable temporary directory (no file changes possible)
          cd "$DEPLOY_DIR"
          tar -czf "${{ github.workspace }}/deploy.tar.gz" .
          
          # Cleanup
          rm -rf "$DEPLOY_DIR"
          
          echo "‚úÖ Deployment archive created: $(du -h deploy.tar.gz | cut -f1)"

      - name: Upload deployment archive
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: deploy.tar.gz
          retention-days: 1

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
      - name: Validate GitHub Secrets
        run: |
          echo "üîç Validating GitHub Secrets..."
          MISSING_SECRETS=()
          
          # Check required secrets
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            MISSING_SECRETS+=("SSH_PRIVATE_KEY")
          fi
          
          if [ -z "${{ secrets.SSH_HOST }}" ]; then
            MISSING_SECRETS+=("SSH_HOST")
          fi
          
          if [ -z "${{ secrets.SSH_USER }}" ]; then
            MISSING_SECRETS+=("SSH_USER")
          fi
          
          if [ -z "${{ secrets.DEPLOY_PATH }}" ]; then
            MISSING_SECRETS+=("DEPLOY_PATH")
          fi
          
          # Report results
          if [ ${#MISSING_SECRETS[@]} -eq 0 ]; then
            echo "‚úÖ All required secrets are set"
            echo ""
            echo "üìã Secrets status:"
            echo "  ‚úÖ SSH_PRIVATE_KEY: Set"
            echo "  ‚úÖ SSH_HOST: Set (${{ secrets.SSH_HOST }})"
            echo "  ‚úÖ SSH_USER: Set (${{ secrets.SSH_USER }})"
            echo "  ‚úÖ DEPLOY_PATH: Set (${{ secrets.DEPLOY_PATH }})"
            if [ -n "${{ secrets.SSH_PASSPHRASE }}" ]; then
              echo "  ‚úÖ SSH_PASSPHRASE: Set"
            else
              echo "  ‚ö†Ô∏è  SSH_PASSPHRASE: Not set (optional, only needed for encrypted keys)"
            fi
          else
            echo "‚ùå Missing required secrets:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "  - $secret"
            done
            echo ""
            echo "üí° Please configure the missing secrets in:"
            echo "   GitHub Repository ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo ""
            echo "Required secrets:"
            echo "  - SSH_PRIVATE_KEY: SSH private key for server access"
            echo "  - SSH_HOST: Server hostname or IP address"
            echo "  - SSH_USER: SSH username"
            echo "  - DEPLOY_PATH: Deployment path on server (e.g., /var/www/app)"
            echo ""
            echo "Optional secrets:"
            echo "  - SSH_PASSPHRASE: Passphrase for encrypted SSH key (if applicable)"
            exit 1
          fi

      - name: Download deployment archive
        uses: actions/download-artifact@v4
        with:
          name: deployment-package

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_PASSPHRASE: ${{ secrets.SSH_PASSPHRASE }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
        run: |
          # Create .ssh directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Validate SSH_PRIVATE_KEY
          if [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "‚ùå Error: SSH_PRIVATE_KEY secret is not set"
            exit 1
          fi
          
          # Write SSH private key using printf to preserve newlines
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key file
          if [ ! -s ~/.ssh/deploy_key ]; then
            echo "‚ùå Error: SSH key file is empty"
            exit 1
          fi
          
          KEY_LINES=$(wc -l < ~/.ssh/deploy_key)
          KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
          echo "‚úÖ SSH key file created ($KEY_LINES lines, $KEY_SIZE bytes)"
          
          # Detailed key format validation
          echo "üìù Key format validation:"
          echo "First line: $(head -1 ~/.ssh/deploy_key)"
          echo "Last line: $(tail -1 ~/.ssh/deploy_key)"
          
          # Check if key has proper BEGIN/END markers
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "‚ùå Error: SSH key does not contain BEGIN PRIVATE KEY marker"
            echo "üìù First 5 lines of key file:"
            head -5 ~/.ssh/deploy_key
            echo ""
            echo "üí° Make sure SSH_PRIVATE_KEY secret includes the full key with BEGIN/END lines"
            exit 1
          fi
          
          if ! grep -q "END.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "‚ùå Error: SSH key does not contain END PRIVATE KEY marker"
            echo "üìù Last 5 lines of key file:"
            tail -5 ~/.ssh/deploy_key
            echo ""
            echo "üí° Make sure SSH_PRIVATE_KEY secret includes the full key with BEGIN/END lines"
            exit 1
          fi
          
          # Detect key type and encryption status
          IS_ENCRYPTED=false
          if grep -q "BEGIN ENCRYPTED PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE="PKCS#8 Encrypted"
            IS_ENCRYPTED=true
          elif grep -q "BEGIN RSA PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE="RSA"
          elif grep -q "BEGIN OPENSSH PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE="OpenSSH"
            # Check if OpenSSH key is encrypted
            if grep -q "ENCRYPTED" ~/.ssh/deploy_key; then
              IS_ENCRYPTED=true
            fi
          elif grep -q "BEGIN EC PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE="ECDSA"
          elif grep -q "BEGIN ED25519 PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE="ED25519"
          elif grep -q "ENCRYPTED" ~/.ssh/deploy_key; then
            KEY_TYPE="Encrypted (unknown format)"
            IS_ENCRYPTED=true
          else
            KEY_TYPE="Unknown"
          fi
          echo "üîë Detected key type: $KEY_TYPE"
          
          # Early check for encrypted keys
          if [ "$IS_ENCRYPTED" = "true" ]; then
            echo "üîí Encrypted key detected"
            if [ -z "$SSH_PASSPHRASE" ]; then
              echo "‚ùå Error: Encrypted key requires SSH_PASSPHRASE secret"
              echo "üí° Solution: Set SSH_PASSPHRASE secret in GitHub Secrets"
              echo ""
              echo "üìù Key file diagnostic:"
              echo "  Lines: $KEY_LINES"
              echo "  Size: $KEY_SIZE bytes"
              echo "  Type: $KEY_TYPE (Encrypted)"
              echo ""
              echo "üìã First 5 lines:"
              head -5 ~/.ssh/deploy_key
              echo ""
              echo "üìã Last 5 lines:"
              tail -5 ~/.ssh/deploy_key
              exit 1
            else
              echo "‚úÖ SSH_PASSPHRASE is set"
            fi
          fi
          
          # Validate key with ssh-keygen
          echo ""
          echo "üîç Validating key with ssh-keygen..."
          if [ "$IS_ENCRYPTED" = "true" ]; then
            # For encrypted keys, we can't validate without passphrase in non-interactive mode
            # We'll skip validation here and handle it during ssh-add
            echo "‚ö†Ô∏è  Skipping key validation (encrypted keys require passphrase)"
            echo "   Key will be validated during SSH connection setup"
          else
            # For non-encrypted keys, validate normally
            if ssh-keygen -l -f ~/.ssh/deploy_key 2>&1; then
              echo "‚úÖ SSH key is valid"
              echo "üîë Public key fingerprint:"
              ssh-keygen -l -f ~/.ssh/deploy_key
            else
              KEYGEN_ERROR=$(ssh-keygen -l -f ~/.ssh/deploy_key 2>&1)
              echo "‚ùå Error: Could not validate key with ssh-keygen"
              echo "Error message: $KEYGEN_ERROR"
              echo ""
              echo "üìù Key file diagnostic:"
              echo "  Lines: $KEY_LINES"
              echo "  Size: $KEY_SIZE bytes"
              echo "  Type: $KEY_TYPE"
              echo ""
              echo "üìã First 10 lines:"
              head -10 ~/.ssh/deploy_key
              echo ""
              echo "üìã Last 10 lines:"
              tail -10 ~/.ssh/deploy_key
              echo ""
              echo "üí° Possible issues:"
              echo "  1. Key format is incorrect (missing BEGIN/END lines)"
              echo "  2. Key has extra whitespace or characters"
              echo "  3. Key is corrupted or incomplete"
              exit 1
            fi
          fi
          
          # Extract and display public key for server setup
          echo ""
          echo "üìã Public key (to be added to server's ~/.ssh/authorized_keys):"
          ssh-keygen -y -f ~/.ssh/deploy_key 2>/dev/null || echo "‚ö†Ô∏è  Could not extract public key (may require passphrase)"
          echo ""
          
          # Add host to known_hosts
          echo "üîë Adding host to known_hosts..."
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts 2>/dev/null
          
          # Create SSH config for easier connection
          cat > ~/.ssh/config << EOF
          Host deploy-server
            HostName $SSH_HOST
            User ${{ secrets.SSH_USER }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking accept-new
            UserKnownHostsFile ~/.ssh/known_hosts
          EOF
          
          chmod 600 ~/.ssh/config
          
          echo "‚úÖ SSH configuration completed"
          
          # Start ssh-agent and add key (with passphrase if needed)
          echo ""
          echo "üîê Setting up ssh-agent..."
          eval $(ssh-agent -s)
          
          # Export ssh-agent environment variables for next steps
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV
          
          if [ "$IS_ENCRYPTED" = "true" ]; then
            echo "üîë Adding encrypted key to ssh-agent..."
            # Install expect for passphrase handling
            sudo apt-get update -qq
            sudo apt-get install -y -qq expect > /dev/null 2>&1
            
            # Create expect script to handle passphrase
            {
              echo '#!/usr/bin/expect -f'
              echo 'set timeout 10'
              echo 'set key_path [lindex $argv 0]'
              echo 'set passphrase [lindex $argv 1]'
              echo ''
              echo 'spawn ssh-add $key_path'
              echo 'expect {'
              echo '  "Enter passphrase for" {'
              echo '    send "$passphrase\r"'
              echo '    expect {'
              echo '      "Identity added:" {'
              echo '        puts "SSH key added successfully"'
              echo '        exit 0'
              echo '      }'
              echo '      "Bad passphrase" {'
              echo '        puts "Error: Incorrect passphrase"'
              echo '        exit 1'
              echo '      }'
              echo '      timeout {'
              echo '        puts "Error: Timeout waiting for response"'
              echo '        exit 1'
              echo '      }'
              echo '    }'
              echo '  }'
              echo '  "Could not open a connection" {'
              echo '    puts "Error: ssh-agent not running"'
              echo '    exit 1'
              echo '  }'
              echo '  "Error loading key" {'
              echo '    puts "Error: Could not load key file"'
              echo '    exit 1'
              echo '  }'
              echo '  timeout {'
              echo '    puts "Error: Timeout waiting for passphrase prompt"'
              echo '    exit 1'
              echo '  }'
              echo '}'
            } > /tmp/ssh-add-expect.exp
            
            chmod +x /tmp/ssh-add-expect.exp
            
            if /tmp/ssh-add-expect.exp ~/.ssh/deploy_key "$SSH_PASSPHRASE"; then
              echo "‚úÖ Encrypted key added to ssh-agent"
            else
              echo "‚ùå Failed to add encrypted key to ssh-agent"
              echo "üí° Check if SSH_PASSPHRASE is correct"
              rm -f /tmp/ssh-add-expect.exp
              exit 1
            fi
            
            rm -f /tmp/ssh-add-expect.exp
          else
            echo "üîë Adding key to ssh-agent..."
            if ssh-add ~/.ssh/deploy_key 2>&1; then
              echo "‚úÖ Key added to ssh-agent"
            else
              echo "‚ö†Ô∏è  Warning: Could not add key to ssh-agent (may require passphrase)"
            fi
          fi
          
          echo ""
          echo "üìã Keys in ssh-agent:"
          ssh-add -l || echo "No keys in ssh-agent"

      - name: Test SSH Connection
        env:
          SSH_PASSPHRASE: ${{ secrets.SSH_PASSPHRASE }}
        run: |
          echo "üîå Testing SSH connection..."
          
          # Check if ssh-agent is available from previous step
          if [ -n "$SSH_AUTH_SOCK" ] && [ -S "$SSH_AUTH_SOCK" ]; then
            echo "‚úÖ ssh-agent is available from previous step"
            export SSH_AUTH_SOCK
            export SSH_AGENT_PID
          else
            echo "‚ö†Ô∏è  ssh-agent not available, starting new one..."
            eval $(ssh-agent -s)
            export SSH_AUTH_SOCK
            export SSH_AGENT_PID
            
            # Check if key is encrypted and add to ssh-agent
            if grep -q "BEGIN ENCRYPTED PRIVATE KEY" ~/.ssh/deploy_key || grep -q "ENCRYPTED" ~/.ssh/deploy_key; then
              if [ -z "$SSH_PASSPHRASE" ]; then
                echo "‚ùå Error: Encrypted key requires SSH_PASSPHRASE"
                exit 1
              fi
              
              echo "üîë Adding encrypted key to ssh-agent..."
              sudo apt-get update -qq
              sudo apt-get install -y -qq expect > /dev/null 2>&1
              
              # Create expect script
              {
                echo '#!/usr/bin/expect -f'
                echo 'set timeout 10'
                echo 'set key_path [lindex $argv 0]'
                echo 'set passphrase [lindex $argv 1]'
                echo ''
                echo 'spawn ssh-add $key_path'
                echo 'expect {'
                echo '  "Enter passphrase for" {'
                echo '    send "$passphrase\r"'
                echo '    expect {'
                echo '      "Identity added:" {'
                echo '        puts "SSH key added successfully"'
                echo '        exit 0'
                echo '      }'
                echo '      "Bad passphrase" {'
                echo '        puts "Error: Incorrect passphrase"'
                echo '        exit 1'
                echo '      }'
                echo '      timeout {'
                echo '        puts "Error: Timeout waiting for response"'
                echo '        exit 1'
                echo '      }'
                echo '    }'
                echo '  }'
                echo '  timeout {'
                echo '    puts "Error: Timeout waiting for passphrase prompt"'
                echo '    exit 1'
                echo '  }'
                echo '}'
              } > /tmp/ssh-add-expect.exp
              
              chmod +x /tmp/ssh-add-expect.exp
              
              if /tmp/ssh-add-expect.exp ~/.ssh/deploy_key "$SSH_PASSPHRASE"; then
                echo "‚úÖ Encrypted key added to ssh-agent"
              else
                echo "‚ùå Failed to add encrypted key"
                exit 1
              fi
              
              rm -f /tmp/ssh-add-expect.exp
            else
              echo "üîë Adding key to ssh-agent..."
              ssh-add ~/.ssh/deploy_key || echo "‚ö†Ô∏è  Could not add key to ssh-agent"
            fi
          fi
          
          echo ""
          echo "üìã SSH Configuration:"
          cat ~/.ssh/config
          echo ""
          echo "üîë SSH Key Info:"
          ls -la ~/.ssh/deploy_key
          echo ""
          echo "üìã Keys in ssh-agent:"
          ssh-add -l || echo "No keys in ssh-agent"
          echo ""
          echo "üîç Attempting connection..."
          # Try connection (ssh-agent will be used if key is loaded)
          if ssh deploy-server "echo '‚úÖ SSH connection successful'" 2>&1; then
            echo "‚úÖ SSH connection test passed"
          else
            echo ""
            echo "‚ùå SSH connection test failed"
            echo ""
            echo "üîç Attempting connection with verbose output for debugging..."
            ssh -vvv deploy-server "echo 'test'" 2>&1 | tail -20 || true
            echo ""
            echo "üìù Troubleshooting steps:"
            echo "1. Verify SSH_PRIVATE_KEY secret contains the full private key (including BEGIN/END lines)"
            echo "2. Ensure the corresponding public key is in ~/.ssh/authorized_keys on the server"
            echo "3. Check SSH_USER and SSH_HOST secrets are correct"
            echo "4. If using encrypted key, verify SSH_PASSPHRASE secret is correct"
            echo "5. Check server logs for authentication failures"
            exit 1
          fi

      - name: Prepare deployment directory
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          echo "üìÅ Preparing deployment directory..."
          ssh deploy-server bash << EOF
          set -e
          
          DEPLOY_PATH="$DEPLOY_PATH"
          TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
          BACKUP_PATH="\${DEPLOY_PATH}_backup_\${TIMESTAMP}"
          
          # Create deployment directory if it doesn't exist
          mkdir -p "\$DEPLOY_PATH"
          
          # Initialize deploy_env file (clear existing)
          > ~/.deploy_env
          
          # Backup current deployment
          if [ -d "\$DEPLOY_PATH" ] && [ "\$(ls -A \$DEPLOY_PATH)" ]; then
            echo "üíæ Creating backup: \$BACKUP_PATH"
            cp -r "\$DEPLOY_PATH" "\$BACKUP_PATH"
            echo "BACKUP_PATH=\$BACKUP_PATH" >> ~/.deploy_env
          fi
          
          # Create releases directory structure
          mkdir -p "\$DEPLOY_PATH/releases"
          mkdir -p "\$DEPLOY_PATH/shared/storage"
          
          # Create required Laravel storage subdirectories
          echo "üìÅ Creating Laravel storage subdirectories..."
          mkdir -p "\$DEPLOY_PATH/shared/storage/framework/views"
          mkdir -p "\$DEPLOY_PATH/shared/storage/framework/cache"
          mkdir -p "\$DEPLOY_PATH/shared/storage/framework/cache/data"
          mkdir -p "\$DEPLOY_PATH/shared/storage/framework/sessions"
          mkdir -p "\$DEPLOY_PATH/shared/storage/framework/testing"
          mkdir -p "\$DEPLOY_PATH/shared/storage/logs"
          mkdir -p "\$DEPLOY_PATH/shared/storage/app/public"
          
          # Set initial permissions
          chmod -R 775 "\$DEPLOY_PATH/shared/storage"
          
          echo "‚úÖ Deployment directory prepared"
          EOF

      - name: Upload and extract deployment package
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          echo "üì§ Uploading deployment package..."
          scp deploy.tar.gz deploy-server:~/deploy.tar.gz
          
          echo "üì¶ Extracting package on server..."
          ssh deploy-server bash << EOF
          set -e
          
          DEPLOY_PATH="$DEPLOY_PATH"
          TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
          RELEASE_PATH="\${DEPLOY_PATH}/releases/\${TIMESTAMP}"
          
          # Create release directory
          mkdir -p "\$RELEASE_PATH"
          
          # Extract deployment package
          tar -xzf ~/deploy.tar.gz -C "\$RELEASE_PATH"
          rm ~/deploy.tar.gz
          
          # Write RELEASE_PATH to deploy_env (append to existing file)
          # Remove existing RELEASE_PATH line if present, then add new one
          if [ -f ~/.deploy_env ]; then
            grep -v "^RELEASE_PATH=" ~/.deploy_env > ~/.deploy_env.tmp || true
            mv ~/.deploy_env.tmp ~/.deploy_env
          fi
          # Use escaped variable to write server-side RELEASE_PATH value
          echo "RELEASE_PATH=\$RELEASE_PATH" >> ~/.deploy_env
          echo "‚úÖ Package extracted to: \$RELEASE_PATH"
          echo "üìù Written to ~/.deploy_env: RELEASE_PATH=\$RELEASE_PATH"
          EOF

      - name: Setup shared resources and permissions
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          echo "üîó Setting up shared resources..."
          ssh deploy-server bash << EOF
          set -e
          
          # Load deployment environment variables
          if [ -f ~/.deploy_env ]; then
            # Get the last non-empty value for each variable
            RELEASE_PATH=\$(grep "^RELEASE_PATH=" ~/.deploy_env | grep -v "RELEASE_PATH=$" | tail -1 | cut -d'=' -f2-)
            BACKUP_PATH=\$(grep "^BACKUP_PATH=" ~/.deploy_env | grep -v "BACKUP_PATH=$" | tail -1 | cut -d'=' -f2-)
            export RELEASE_PATH
            export BACKUP_PATH
            echo "üìã Loaded RELEASE_PATH: \$RELEASE_PATH"
            if [ -n "\$BACKUP_PATH" ]; then
              echo "üìã Loaded BACKUP_PATH: \$BACKUP_PATH"
            fi
          else
            echo "‚ùå Error: ~/.deploy_env file not found"
            exit 1
          fi
          
          DEPLOY_PATH="$DEPLOY_PATH"
          
          # Verify variables are set
          if [ -z "\$RELEASE_PATH" ]; then
            echo "‚ùå Error: RELEASE_PATH is not set"
            echo "üìù Contents of ~/.deploy_env:"
            cat ~/.deploy_env || echo "File is empty or cannot be read"
            exit 1
          fi
          
          if [ -z "\$DEPLOY_PATH" ]; then
            echo "‚ùå Error: DEPLOY_PATH is not set"
            exit 1
          fi
          
          echo "üìã Using DEPLOY_PATH: \$DEPLOY_PATH"
          echo "üìã Using RELEASE_PATH: \$RELEASE_PATH"
          
          # Verify directories exist
          if [ ! -d "\$RELEASE_PATH" ]; then
            echo "‚ùå Error: RELEASE_PATH directory does not exist: \$RELEASE_PATH"
            exit 1
          fi
          
          if [ ! -d "\$DEPLOY_PATH/shared/storage" ]; then
            echo "‚ö†Ô∏è  Warning: Shared storage directory does not exist, creating it..."
            mkdir -p "\$DEPLOY_PATH/shared/storage"
          fi
          
          # Ensure all required Laravel storage subdirectories exist
          echo "üìÅ Ensuring Laravel storage subdirectories exist..."
          mkdir -p "\$DEPLOY_PATH/shared/storage/framework/views"
          mkdir -p "\$DEPLOY_PATH/shared/storage/framework/cache"
          mkdir -p "\$DEPLOY_PATH/shared/storage/framework/cache/data"
          mkdir -p "\$DEPLOY_PATH/shared/storage/framework/sessions"
          mkdir -p "\$DEPLOY_PATH/shared/storage/framework/testing"
          mkdir -p "\$DEPLOY_PATH/shared/storage/logs"
          mkdir -p "\$DEPLOY_PATH/shared/storage/app/public"
          
          # Link shared storage (use absolute paths)
          if [ -d "\$RELEASE_PATH/storage" ] || [ -L "\$RELEASE_PATH/storage" ]; then
            echo "üóëÔ∏è  Removing existing storage directory/link..."
            rm -rf "\$RELEASE_PATH/storage"
          fi
          
          echo "üîó Creating symlink from \$RELEASE_PATH/storage to \$DEPLOY_PATH/shared/storage"
          ln -s "\$DEPLOY_PATH/shared/storage" "\$RELEASE_PATH/storage"
          
          # Verify symlink was created
          if [ -L "\$RELEASE_PATH/storage" ]; then
            echo "‚úÖ Symlink created successfully"
            ls -la "\$RELEASE_PATH/storage"
          else
            echo "‚ùå Error: Failed to create symlink"
            exit 1
          fi
          
          # Copy .env if it exists in the main deployment path
          if [ -f "\$DEPLOY_PATH/.env" ]; then
            echo "üìã Copying .env file..."
            cp "\$DEPLOY_PATH/.env" "\$RELEASE_PATH/.env"
          else
            echo "‚ö†Ô∏è  Warning: .env file not found at \$DEPLOY_PATH/.env"
          fi
          
          # Create bootstrap/cache directory if it doesn't exist
          echo "üìÅ Ensuring bootstrap/cache directory exists..."
          mkdir -p "\$RELEASE_PATH/bootstrap/cache"
          
          # Set permissions
          echo "üîê Setting permissions..."
          chmod -R 755 "\$RELEASE_PATH"
          chmod -R 775 "\$DEPLOY_PATH/shared/storage"
          chmod -R 775 "\$RELEASE_PATH/bootstrap/cache"
          
          # Verify storage structure
          echo "üîç Verifying storage structure..."
          echo "Storage symlink:"
          ls -la "\$RELEASE_PATH/storage" || echo "‚ö†Ô∏è  Warning: Storage symlink verification failed"
          echo ""
          echo "Storage subdirectories:"
          ls -la "\$DEPLOY_PATH/shared/storage/" || echo "‚ö†Ô∏è  Warning: Could not list storage directory"
          echo ""
          echo "Framework subdirectories:"
          ls -la "\$DEPLOY_PATH/shared/storage/framework/" || echo "‚ö†Ô∏è  Warning: Could not list framework directory"
          
          echo "‚úÖ Shared resources configured"
          EOF

      - name: Run deployment commands
        run: |
          echo "‚öôÔ∏è  Running deployment commands..."
          ssh deploy-server bash << EOF
          set -e
          
          # Load deployment environment variables
          if [ -f ~/.deploy_env ]; then
            # Get the last non-empty value for each variable
            RELEASE_PATH=\$(grep "^RELEASE_PATH=" ~/.deploy_env | grep -v "RELEASE_PATH=$" | tail -1 | cut -d'=' -f2-)
            export RELEASE_PATH
            echo "üìã Loaded RELEASE_PATH: \$RELEASE_PATH"
          else
            echo "‚ùå Error: ~/.deploy_env file not found"
            exit 1
          fi
          
          # Verify RELEASE_PATH is set
          if [ -z "\$RELEASE_PATH" ]; then
            echo "‚ùå Error: RELEASE_PATH is not set"
            echo "üìù Contents of ~/.deploy_env:"
            cat ~/.deploy_env || echo "File is empty or cannot be read"
            exit 1
          fi
          
          # Verify RELEASE_PATH directory exists
          if [ ! -d "\$RELEASE_PATH" ]; then
            echo "‚ùå Error: RELEASE_PATH directory does not exist: \$RELEASE_PATH"
            echo "üìù Checking releases directory:"
            ls -la "\$(dirname \$RELEASE_PATH)" || true
            exit 1
          fi
          
          cd "\$RELEASE_PATH"
          
          # Check PHP version
          echo "üîç Checking PHP version..."
          PHP_VERSION=\$(php -r "echo PHP_VERSION;")
          PHP_MAJOR_MINOR=\$(php -r "echo PHP_MAJOR_VERSION . '.' . PHP_MINOR_VERSION;")
          echo "üìã Current PHP version: \$PHP_VERSION"
          
          # Check if PHP version meets requirements (>= 8.2.0)
          PHP_REQUIRED="8.2.0"
          if [ "\$(printf '%s\n' "\$PHP_REQUIRED" "\$PHP_VERSION" | sort -V | head -n1)" != "\$PHP_REQUIRED" ]; then
            echo "‚ùå Error: PHP version \$PHP_VERSION is too old"
            echo "üìã Required: PHP >= \$PHP_REQUIRED"
            echo ""
            echo "üí° Solutions:"
            echo "  1. Upgrade PHP on the server to version 8.2 or higher"
            echo "  2. Use a different PHP version if multiple versions are installed:"
            echo "     - php8.2 artisan migrate"
            echo "     - /usr/bin/php8.2 artisan migrate"
            echo "  3. Check available PHP versions:"
            echo "     - which -a php"
            echo "     - ls -la /usr/bin/php*"
            exit 1
          fi
          
          echo "‚úÖ PHP version meets requirements"
          echo ""
          
          # Run Laravel deployment commands
          echo "üìù Running migrations..."
          php artisan migrate --force
          
          echo "üóëÔ∏è  Clearing caches..."
          # Temporarily disable exit on error for cache clearing (non-critical operations)
          set +e
          php artisan config:clear && echo "‚úÖ Config cache cleared" || echo "‚ö†Ô∏è  Warning: config:clear failed (may not be cached)"
          php artisan cache:clear && echo "‚úÖ Application cache cleared" || echo "‚ö†Ô∏è  Warning: cache:clear failed"
          php artisan route:clear && echo "‚úÖ Route cache cleared" || echo "‚ö†Ô∏è  Warning: route:clear failed (may not be cached)"
          php artisan view:clear && echo "‚úÖ View cache cleared" || echo "‚ö†Ô∏è  Warning: view:clear failed (views may not exist yet)"
          set -e
          
          echo "üì¶ Optimizing..."
          # Cache operations - continue even if some fail
          set +e
          php artisan config:cache && echo "‚úÖ Config cached" || echo "‚ö†Ô∏è  Warning: config:cache failed"
          php artisan route:cache && echo "‚úÖ Routes cached" || echo "‚ö†Ô∏è  Warning: route:cache failed"
          php artisan view:cache && echo "‚úÖ Views cached" || echo "‚ö†Ô∏è  Warning: view:cache failed (views may not exist)"
          set -e
          
          echo "‚úÖ Deployment commands completed"
          EOF

      - name: Switch to new release
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          echo "üîÑ Switching to new release..."
          ssh deploy-server bash << EOF
          set -e
          
          # Load deployment environment variables
          if [ -f ~/.deploy_env ]; then
            RELEASE_PATH=\$(grep "^RELEASE_PATH=" ~/.deploy_env | grep -v "RELEASE_PATH=$" | tail -1 | cut -d'=' -f2-)
            export RELEASE_PATH
          fi
          
          DEPLOY_PATH="$DEPLOY_PATH"
          
          # Remove old current symlink or directory
          if [ -L "\$DEPLOY_PATH/current" ]; then
            rm "\$DEPLOY_PATH/current"
          elif [ -d "\$DEPLOY_PATH/current" ]; then
            rm -rf "\$DEPLOY_PATH/current"
          fi
          
          # Create symlink to new release
          ln -s "\$RELEASE_PATH" "\$DEPLOY_PATH/current"
          
          echo "‚úÖ Switched to new release"
          EOF

      - name: Cleanup old releases
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          echo "üßπ Cleaning up old releases..."
          ssh deploy-server bash << EOF
          set -e
          
          DEPLOY_PATH="$DEPLOY_PATH"
          
          # Keep only the latest 5 releases
          cd "\$DEPLOY_PATH/releases"
          ls -t | tail -n +6 | xargs -r rm -rf
          
          # Remove old backups (keep last 3)
          cd "\$(dirname "\$DEPLOY_PATH")"
          ls -td \${DEPLOY_PATH##*/}_backup_* 2>/dev/null | tail -n +4 | xargs -r rm -rf || true
          
          echo "‚úÖ Cleanup completed"
          EOF

      - name: Verify deployment
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "üìä Deployment summary:"
          ssh deploy-server bash << EOF
          # Load deployment environment variables (optional for summary)
          if [ -f ~/.deploy_env ]; then
            RELEASE_PATH=\$(grep "^RELEASE_PATH=" ~/.deploy_env | grep -v "RELEASE_PATH=$" | tail -1 | cut -d'=' -f2-)
            export RELEASE_PATH
          fi
          
          DEPLOY_PATH="$DEPLOY_PATH"
          
          echo "Current release: \$(readlink \$DEPLOY_PATH/current)"
          echo "Total releases: \$(ls -1 \$DEPLOY_PATH/releases | wc -l)"
          
          # Cleanup deploy env
          rm -f ~/.deploy_env
          EOF

