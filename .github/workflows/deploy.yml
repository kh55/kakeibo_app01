name: Deploy

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, pdo_mysql, zip, gd, exif, pcntl, bcmath, xml, curl

      - name: Copy .env
        run: php -r "file_exists('.env') || copy('.env.example', '.env');"

      - name: Install Dependencies
        run: composer install -q --no-ansi --no-interaction --no-scripts --no-progress --prefer-dist

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install NPM dependencies
        run: npm ci

      - name: Build assets
        run: npm run build

      - name: Generate key
        run: php artisan key:generate

      - name: Directory Permissions
        run: chmod -R 775 storage bootstrap/cache

      - name: Create Database
        run: |
          mkdir -p database
          touch database/database.sqlite

      - name: Run Migrations
        env:
          DB_CONNECTION: sqlite
          DB_DATABASE: database/database.sqlite
        run: php artisan migrate --force

      - name: Execute tests (Unit and Feature tests) via PHPUnit
        env:
          DB_CONNECTION: sqlite
          DB_DATABASE: database/database.sqlite
        run: vendor/bin/phpunit

      - name: Run Laravel Pint
        run: vendor/bin/pint --test

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, pdo_mysql, zip, gd, exif, pcntl, bcmath, xml, curl

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Composer dependencies
        run: composer install --no-dev --optimize-autoloader --no-interaction

      - name: Install NPM dependencies
        run: npm ci

      - name: Build assets for production
        run: npm run build

      - name: Create deployment archive
        run: |
          # Wait for file system to sync to ensure all writes are complete
          sync
          
          # Create temporary directory for deployment package
          DEPLOY_DIR="/tmp/deploy-package"
          mkdir -p "$DEPLOY_DIR"
          
          # Copy files to temporary directory, excluding unnecessary files
          find . -mindepth 1 -maxdepth 1 \
            ! -name '.git' \
            ! -name '.github' \
            ! -name 'node_modules' \
            ! -name 'tests' \
            ! -name '.env*' \
            ! -name 'docker*' \
            ! -name 'Dockerfile' \
            ! -name '.dockerignore' \
            ! -name 'phpunit.xml' \
            ! -name '*.md' \
            ! -name 'deploy.tar.gz' \
            -exec cp -r {} "$DEPLOY_DIR/" \;
          
          # Create archive from stable temporary directory (no file changes possible)
          cd "$DEPLOY_DIR"
          tar -czf "${{ github.workspace }}/deploy.tar.gz" .
          
          # Cleanup
          rm -rf "$DEPLOY_DIR"
          
          echo "âœ… Deployment archive created: $(du -h deploy.tar.gz | cut -f1)"

      - name: Upload deployment archive
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: deploy.tar.gz
          retention-days: 1

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Validate GitHub Secrets
        run: |
          echo "ğŸ” Validating GitHub Secrets..."
          MISSING_SECRETS=()
          
          # Check required secrets
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            MISSING_SECRETS+=("SSH_PRIVATE_KEY")
          fi
          
          if [ -z "${{ secrets.SSH_HOST }}" ]; then
            MISSING_SECRETS+=("SSH_HOST")
          fi
          
          if [ -z "${{ secrets.SSH_USER }}" ]; then
            MISSING_SECRETS+=("SSH_USER")
          fi
          
          if [ -z "${{ secrets.DEPLOY_PATH }}" ]; then
            MISSING_SECRETS+=("DEPLOY_PATH")
          fi
          
          # Report results
          if [ ${#MISSING_SECRETS[@]} -eq 0 ]; then
            echo "âœ… All required secrets are set"
            echo ""
            echo "ğŸ“‹ Secrets status:"
            echo "  âœ… SSH_PRIVATE_KEY: Set"
            echo "  âœ… SSH_HOST: Set (${{ secrets.SSH_HOST }})"
            echo "  âœ… SSH_USER: Set (${{ secrets.SSH_USER }})"
            echo "  âœ… DEPLOY_PATH: Set (${{ secrets.DEPLOY_PATH }})"
            if [ -n "${{ secrets.SSH_PASSPHRASE }}" ]; then
              echo "  âœ… SSH_PASSPHRASE: Set"
            else
              echo "  âš ï¸  SSH_PASSPHRASE: Not set (optional, only needed for encrypted keys)"
            fi
          else
            echo "âŒ Missing required secrets:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "  - $secret"
            done
            echo ""
            echo "ğŸ’¡ Please configure the missing secrets in:"
            echo "   GitHub Repository â†’ Settings â†’ Secrets and variables â†’ Actions"
            echo ""
            echo "Required secrets:"
            echo "  - SSH_PRIVATE_KEY: SSH private key for server access"
            echo "  - SSH_HOST: Server hostname or IP address"
            echo "  - SSH_USER: SSH username"
            echo "  - DEPLOY_PATH: Deployment path on server (e.g., /var/www/app)"
            echo ""
            echo "Optional secrets:"
            echo "  - SSH_PASSPHRASE: Passphrase for encrypted SSH key (if applicable)"
            exit 1
          fi

      - name: Download deployment archive
        uses: actions/download-artifact@v4
        with:
          name: deployment-package

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_PASSPHRASE: ${{ secrets.SSH_PASSPHRASE }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
        run: |
          # Create .ssh directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Validate SSH_PRIVATE_KEY
          if [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "âŒ Error: SSH_PRIVATE_KEY secret is not set"
            exit 1
          fi
          
          # Write SSH private key using printf to preserve newlines
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key file
          if [ ! -s ~/.ssh/deploy_key ]; then
            echo "âŒ Error: SSH key file is empty"
            exit 1
          fi
          
          KEY_LINES=$(wc -l < ~/.ssh/deploy_key)
          KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
          echo "âœ… SSH key file created ($KEY_LINES lines, $KEY_SIZE bytes)"
          
          # Detailed key format validation
          echo "ğŸ“ Key format validation:"
          echo "First line: $(head -1 ~/.ssh/deploy_key)"
          echo "Last line: $(tail -1 ~/.ssh/deploy_key)"
          
          # Check if key has proper BEGIN/END markers
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "âŒ Error: SSH key does not contain BEGIN PRIVATE KEY marker"
            echo "ğŸ“ First 5 lines of key file:"
            head -5 ~/.ssh/deploy_key
            echo ""
            echo "ğŸ’¡ Make sure SSH_PRIVATE_KEY secret includes the full key with BEGIN/END lines"
            exit 1
          fi
          
          if ! grep -q "END.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "âŒ Error: SSH key does not contain END PRIVATE KEY marker"
            echo "ğŸ“ Last 5 lines of key file:"
            tail -5 ~/.ssh/deploy_key
            echo ""
            echo "ğŸ’¡ Make sure SSH_PRIVATE_KEY secret includes the full key with BEGIN/END lines"
            exit 1
          fi
          
          # Detect key type and encryption status
          IS_ENCRYPTED=false
          if grep -q "BEGIN ENCRYPTED PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE="PKCS#8 Encrypted"
            IS_ENCRYPTED=true
          elif grep -q "BEGIN RSA PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE="RSA"
          elif grep -q "BEGIN OPENSSH PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE="OpenSSH"
            # Check if OpenSSH key is encrypted
            if grep -q "ENCRYPTED" ~/.ssh/deploy_key; then
              IS_ENCRYPTED=true
            fi
          elif grep -q "BEGIN EC PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE="ECDSA"
          elif grep -q "BEGIN ED25519 PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE="ED25519"
          elif grep -q "ENCRYPTED" ~/.ssh/deploy_key; then
            KEY_TYPE="Encrypted (unknown format)"
            IS_ENCRYPTED=true
          else
            KEY_TYPE="Unknown"
          fi
          echo "ğŸ”‘ Detected key type: $KEY_TYPE"
          
          # Early check for encrypted keys
          if [ "$IS_ENCRYPTED" = "true" ]; then
            echo "ğŸ”’ Encrypted key detected"
            if [ -z "$SSH_PASSPHRASE" ]; then
              echo "âŒ Error: Encrypted key requires SSH_PASSPHRASE secret"
              echo "ğŸ’¡ Solution: Set SSH_PASSPHRASE secret in GitHub Secrets"
              echo ""
              echo "ğŸ“ Key file diagnostic:"
              echo "  Lines: $KEY_LINES"
              echo "  Size: $KEY_SIZE bytes"
              echo "  Type: $KEY_TYPE (Encrypted)"
              echo ""
              echo "ğŸ“‹ First 5 lines:"
              head -5 ~/.ssh/deploy_key
              echo ""
              echo "ğŸ“‹ Last 5 lines:"
              tail -5 ~/.ssh/deploy_key
              exit 1
            else
              echo "âœ… SSH_PASSPHRASE is set"
            fi
          fi
          
          # Validate key with ssh-keygen
          echo ""
          echo "ğŸ” Validating key with ssh-keygen..."
          if [ "$IS_ENCRYPTED" = "true" ]; then
            # For encrypted keys, we can't validate without passphrase in non-interactive mode
            # We'll skip validation here and handle it during ssh-add
            echo "âš ï¸  Skipping key validation (encrypted keys require passphrase)"
            echo "   Key will be validated during SSH connection setup"
          else
            # For non-encrypted keys, validate normally
            if ssh-keygen -l -f ~/.ssh/deploy_key 2>&1; then
              echo "âœ… SSH key is valid"
              echo "ğŸ”‘ Public key fingerprint:"
              ssh-keygen -l -f ~/.ssh/deploy_key
            else
              KEYGEN_ERROR=$(ssh-keygen -l -f ~/.ssh/deploy_key 2>&1)
              echo "âŒ Error: Could not validate key with ssh-keygen"
              echo "Error message: $KEYGEN_ERROR"
              echo ""
              echo "ğŸ“ Key file diagnostic:"
              echo "  Lines: $KEY_LINES"
              echo "  Size: $KEY_SIZE bytes"
              echo "  Type: $KEY_TYPE"
              echo ""
              echo "ğŸ“‹ First 10 lines:"
              head -10 ~/.ssh/deploy_key
              echo ""
              echo "ğŸ“‹ Last 10 lines:"
              tail -10 ~/.ssh/deploy_key
              echo ""
              echo "ğŸ’¡ Possible issues:"
              echo "  1. Key format is incorrect (missing BEGIN/END lines)"
              echo "  2. Key has extra whitespace or characters"
              echo "  3. Key is corrupted or incomplete"
              exit 1
            fi
          fi
          
          # Extract and display public key for server setup
          echo ""
          echo "ğŸ“‹ Public key (to be added to server's ~/.ssh/authorized_keys):"
          ssh-keygen -y -f ~/.ssh/deploy_key 2>/dev/null || echo "âš ï¸  Could not extract public key (may require passphrase)"
          echo ""
          
          # Add host to known_hosts
          echo "ğŸ”‘ Adding host to known_hosts..."
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts 2>/dev/null
          
          # Create SSH config for easier connection
          cat > ~/.ssh/config << EOF
          Host deploy-server
            HostName $SSH_HOST
            User ${{ secrets.SSH_USER }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking accept-new
            UserKnownHostsFile ~/.ssh/known_hosts
          EOF
          
          chmod 600 ~/.ssh/config
          
          echo "âœ… SSH configuration completed"
          
          # Start ssh-agent and add key (with passphrase if needed)
          echo ""
          echo "ğŸ” Setting up ssh-agent..."
          eval $(ssh-agent -s)
          
          # Export ssh-agent environment variables for next steps
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV
          
          if [ "$IS_ENCRYPTED" = "true" ]; then
            echo "ğŸ”‘ Adding encrypted key to ssh-agent..."
            # Install expect for passphrase handling
            sudo apt-get update -qq
            sudo apt-get install -y -qq expect > /dev/null 2>&1
            
            # Create expect script to handle passphrase
            {
              echo '#!/usr/bin/expect -f'
              echo 'set timeout 10'
              echo 'set key_path [lindex $argv 0]'
              echo 'set passphrase [lindex $argv 1]'
              echo ''
              echo 'spawn ssh-add $key_path'
              echo 'expect {'
              echo '  "Enter passphrase for" {'
              echo '    send "$passphrase\r"'
              echo '    expect {'
              echo '      "Identity added:" {'
              echo '        puts "SSH key added successfully"'
              echo '        exit 0'
              echo '      }'
              echo '      "Bad passphrase" {'
              echo '        puts "Error: Incorrect passphrase"'
              echo '        exit 1'
              echo '      }'
              echo '      timeout {'
              echo '        puts "Error: Timeout waiting for response"'
              echo '        exit 1'
              echo '      }'
              echo '    }'
              echo '  }'
              echo '  "Could not open a connection" {'
              echo '    puts "Error: ssh-agent not running"'
              echo '    exit 1'
              echo '  }'
              echo '  "Error loading key" {'
              echo '    puts "Error: Could not load key file"'
              echo '    exit 1'
              echo '  }'
              echo '  timeout {'
              echo '    puts "Error: Timeout waiting for passphrase prompt"'
              echo '    exit 1'
              echo '  }'
              echo '}'
            } > /tmp/ssh-add-expect.exp
            
            chmod +x /tmp/ssh-add-expect.exp
            
            if /tmp/ssh-add-expect.exp ~/.ssh/deploy_key "$SSH_PASSPHRASE"; then
              echo "âœ… Encrypted key added to ssh-agent"
            else
              echo "âŒ Failed to add encrypted key to ssh-agent"
              echo "ğŸ’¡ Check if SSH_PASSPHRASE is correct"
              rm -f /tmp/ssh-add-expect.exp
              exit 1
            fi
            
            rm -f /tmp/ssh-add-expect.exp
          else
            echo "ğŸ”‘ Adding key to ssh-agent..."
            if ssh-add ~/.ssh/deploy_key 2>&1; then
              echo "âœ… Key added to ssh-agent"
            else
              echo "âš ï¸  Warning: Could not add key to ssh-agent (may require passphrase)"
            fi
          fi
          
          echo ""
          echo "ğŸ“‹ Keys in ssh-agent:"
          ssh-add -l || echo "No keys in ssh-agent"

      - name: Test SSH Connection
        env:
          SSH_PASSPHRASE: ${{ secrets.SSH_PASSPHRASE }}
        run: |
          echo "ğŸ”Œ Testing SSH connection..."
          
          # Check if ssh-agent is available from previous step
          if [ -n "$SSH_AUTH_SOCK" ] && [ -S "$SSH_AUTH_SOCK" ]; then
            echo "âœ… ssh-agent is available from previous step"
            export SSH_AUTH_SOCK
            export SSH_AGENT_PID
          else
            echo "âš ï¸  ssh-agent not available, starting new one..."
            eval $(ssh-agent -s)
            export SSH_AUTH_SOCK
            export SSH_AGENT_PID
            
            # Check if key is encrypted and add to ssh-agent
            if grep -q "BEGIN ENCRYPTED PRIVATE KEY" ~/.ssh/deploy_key || grep -q "ENCRYPTED" ~/.ssh/deploy_key; then
              if [ -z "$SSH_PASSPHRASE" ]; then
                echo "âŒ Error: Encrypted key requires SSH_PASSPHRASE"
                exit 1
              fi
              
              echo "ğŸ”‘ Adding encrypted key to ssh-agent..."
              sudo apt-get update -qq
              sudo apt-get install -y -qq expect > /dev/null 2>&1
              
              # Create expect script
              {
                echo '#!/usr/bin/expect -f'
                echo 'set timeout 10'
                echo 'set key_path [lindex $argv 0]'
                echo 'set passphrase [lindex $argv 1]'
                echo ''
                echo 'spawn ssh-add $key_path'
                echo 'expect {'
                echo '  "Enter passphrase for" {'
                echo '    send "$passphrase\r"'
                echo '    expect {'
                echo '      "Identity added:" {'
                echo '        puts "SSH key added successfully"'
                echo '        exit 0'
                echo '      }'
                echo '      "Bad passphrase" {'
                echo '        puts "Error: Incorrect passphrase"'
                echo '        exit 1'
                echo '      }'
                echo '      timeout {'
                echo '        puts "Error: Timeout waiting for response"'
                echo '        exit 1'
                echo '      }'
                echo '    }'
                echo '  }'
                echo '  timeout {'
                echo '    puts "Error: Timeout waiting for passphrase prompt"'
                echo '    exit 1'
                echo '  }'
                echo '}'
              } > /tmp/ssh-add-expect.exp
              
              chmod +x /tmp/ssh-add-expect.exp
              
              if /tmp/ssh-add-expect.exp ~/.ssh/deploy_key "$SSH_PASSPHRASE"; then
                echo "âœ… Encrypted key added to ssh-agent"
              else
                echo "âŒ Failed to add encrypted key"
                exit 1
              fi
              
              rm -f /tmp/ssh-add-expect.exp
            else
              echo "ğŸ”‘ Adding key to ssh-agent..."
              ssh-add ~/.ssh/deploy_key || echo "âš ï¸  Could not add key to ssh-agent"
            fi
          fi
          
          echo ""
          echo "ğŸ“‹ SSH Configuration:"
          cat ~/.ssh/config
          echo ""
          echo "ğŸ”‘ SSH Key Info:"
          ls -la ~/.ssh/deploy_key
          echo ""
          echo "ğŸ“‹ Keys in ssh-agent:"
          ssh-add -l || echo "No keys in ssh-agent"
          echo ""
          echo "ğŸ” Attempting connection..."
          # Try connection (ssh-agent will be used if key is loaded)
          if ssh deploy-server "echo 'âœ… SSH connection successful'" 2>&1; then
            echo "âœ… SSH connection test passed"
          else
            echo ""
            echo "âŒ SSH connection test failed"
            echo ""
            echo "ğŸ” Attempting connection with verbose output for debugging..."
            ssh -vvv deploy-server "echo 'test'" 2>&1 | tail -20 || true
            echo ""
            echo "ğŸ“ Troubleshooting steps:"
            echo "1. Verify SSH_PRIVATE_KEY secret contains the full private key (including BEGIN/END lines)"
            echo "2. Ensure the corresponding public key is in ~/.ssh/authorized_keys on the server"
            echo "3. Check SSH_USER and SSH_HOST secrets are correct"
            echo "4. If using encrypted key, verify SSH_PASSPHRASE secret is correct"
            echo "5. Check server logs for authentication failures"
            exit 1
          fi

      - name: Prepare deployment directory
        run: |
          echo "ğŸ“ Preparing deployment directory..."
          ssh deploy-server << 'ENDSSH'
          set -e
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          BACKUP_PATH="${DEPLOY_PATH}_backup_${TIMESTAMP}"
          
          # Create deployment directory if it doesn't exist
          mkdir -p "$DEPLOY_PATH"
          
          # Backup current deployment
          if [ -d "$DEPLOY_PATH" ] && [ "$(ls -A $DEPLOY_PATH)" ]; then
            echo "ğŸ’¾ Creating backup: $BACKUP_PATH"
            cp -r "$DEPLOY_PATH" "$BACKUP_PATH"
            echo "BACKUP_PATH=$BACKUP_PATH" >> ~/.deploy_env
          fi
          
          # Create releases directory structure
          mkdir -p "$DEPLOY_PATH/releases"
          mkdir -p "$DEPLOY_PATH/shared/storage"
          
          echo "âœ… Deployment directory prepared"
          ENDSSH

      - name: Upload and extract deployment package
        run: |
          echo "ğŸ“¤ Uploading deployment package..."
          scp deploy.tar.gz deploy-server:~/deploy.tar.gz
          
          echo "ğŸ“¦ Extracting package on server..."
          ssh deploy-server << 'ENDSSH'
          set -e
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          RELEASE_PATH="$DEPLOY_PATH/releases/$TIMESTAMP"
          
          # Create release directory
          mkdir -p "$RELEASE_PATH"
          
          # Extract deployment package
          tar -xzf ~/deploy.tar.gz -C "$RELEASE_PATH"
          rm ~/deploy.tar.gz
          
          echo "RELEASE_PATH=$RELEASE_PATH" >> ~/.deploy_env
          echo "âœ… Package extracted to: $RELEASE_PATH"
          ENDSSH

      - name: Setup shared resources and permissions
        run: |
          echo "ğŸ”— Setting up shared resources..."
          ssh deploy-server << 'ENDSSH'
          set -e
          source ~/.deploy_env
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          
          # Link shared storage
          if [ -d "$RELEASE_PATH/storage" ]; then
            rm -rf "$RELEASE_PATH/storage"
          fi
          ln -s "$DEPLOY_PATH/shared/storage" "$RELEASE_PATH/storage"
          
          # Copy .env if it exists in the main deployment path
          if [ -f "$DEPLOY_PATH/.env" ]; then
            cp "$DEPLOY_PATH/.env" "$RELEASE_PATH/.env"
          fi
          
          # Set permissions
          chmod -R 755 "$RELEASE_PATH"
          chmod -R 775 "$DEPLOY_PATH/shared/storage"
          
          echo "âœ… Shared resources configured"
          ENDSSH

      - name: Run deployment commands
        run: |
          echo "âš™ï¸  Running deployment commands..."
          ssh deploy-server << 'ENDSSH'
          set -e
          source ~/.deploy_env
          
          cd "$RELEASE_PATH"
          
          # Run Laravel deployment commands
          echo "ğŸ“ Running migrations..."
          php artisan migrate --force
          
          echo "ğŸ—‘ï¸  Clearing caches..."
          php artisan config:clear
          php artisan cache:clear
          php artisan route:clear
          php artisan view:clear
          
          echo "ğŸ“¦ Optimizing..."
          php artisan config:cache
          php artisan route:cache
          php artisan view:cache
          
          echo "âœ… Deployment commands completed"
          ENDSSH

      - name: Switch to new release
        run: |
          echo "ğŸ”„ Switching to new release..."
          ssh deploy-server << 'ENDSSH'
          set -e
          source ~/.deploy_env
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          
          # Remove old current symlink or directory
          if [ -L "$DEPLOY_PATH/current" ]; then
            rm "$DEPLOY_PATH/current"
          elif [ -d "$DEPLOY_PATH/current" ]; then
            rm -rf "$DEPLOY_PATH/current"
          fi
          
          # Create symlink to new release
          ln -s "$RELEASE_PATH" "$DEPLOY_PATH/current"
          
          echo "âœ… Switched to new release"
          ENDSSH

      - name: Cleanup old releases
        run: |
          echo "ğŸ§¹ Cleaning up old releases..."
          ssh deploy-server << 'ENDSSH'
          set -e
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          
          # Keep only the latest 5 releases
          cd "$DEPLOY_PATH/releases"
          ls -t | tail -n +6 | xargs -r rm -rf
          
          # Remove old backups (keep last 3)
          cd "$(dirname "$DEPLOY_PATH")"
          ls -td ${DEPLOY_PATH##*/}_backup_* 2>/dev/null | tail -n +4 | xargs -r rm -rf || true
          
          echo "âœ… Cleanup completed"
          ENDSSH

      - name: Verify deployment
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ğŸ“Š Deployment summary:"
          ssh deploy-server << 'ENDSSH'
          source ~/.deploy_env
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          
          echo "Current release: $(readlink $DEPLOY_PATH/current)"
          echo "Total releases: $(ls -1 $DEPLOY_PATH/releases | wc -l)"
          
          # Cleanup deploy env
          rm -f ~/.deploy_env
          ENDSSH

