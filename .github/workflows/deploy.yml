name: Deploy

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, pdo_mysql, zip, gd, exif, pcntl, bcmath, xml, curl

      - name: Copy .env
        run: php -r "file_exists('.env') || copy('.env.example', '.env');"

      - name: Install Dependencies
        run: composer install -q --no-ansi --no-interaction --no-scripts --no-progress --prefer-dist

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install NPM dependencies
        run: npm ci

      - name: Build assets
        run: npm run build

      - name: Generate key
        run: php artisan key:generate

      - name: Directory Permissions
        run: chmod -R 775 storage bootstrap/cache

      - name: Create Database
        run: |
          mkdir -p database
          touch database/database.sqlite

      - name: Run Migrations
        env:
          DB_CONNECTION: sqlite
          DB_DATABASE: database/database.sqlite
        run: php artisan migrate --force

      - name: Execute tests (Unit and Feature tests) via PHPUnit
        env:
          DB_CONNECTION: sqlite
          DB_DATABASE: database/database.sqlite
        run: vendor/bin/phpunit

      - name: Run Laravel Pint
        run: vendor/bin/pint --test

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, pdo_mysql, zip, gd, exif, pcntl, bcmath, xml, curl

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Composer dependencies
        run: composer install --no-dev --optimize-autoloader --no-interaction

      - name: Install NPM dependencies
        run: npm ci

      - name: Build assets for production
        run: npm run build

      - name: Create deployment archive
        run: |
          # Wait for file system to sync to ensure all writes are complete
          sync
          
          # Create temporary directory for deployment package
          DEPLOY_DIR="/tmp/deploy-package"
          mkdir -p "$DEPLOY_DIR"
          
          # Copy files to temporary directory, excluding unnecessary files
          find . -mindepth 1 -maxdepth 1 \
            ! -name '.git' \
            ! -name '.github' \
            ! -name 'node_modules' \
            ! -name 'tests' \
            ! -name '.env*' \
            ! -name 'docker*' \
            ! -name 'Dockerfile' \
            ! -name '.dockerignore' \
            ! -name 'phpunit.xml' \
            ! -name '*.md' \
            ! -name 'deploy.tar.gz' \
            -exec cp -r {} "$DEPLOY_DIR/" \;
          
          # Create archive from stable temporary directory (no file changes possible)
          cd "$DEPLOY_DIR"
          tar -czf "${{ github.workspace }}/deploy.tar.gz" .
          
          # Cleanup
          rm -rf "$DEPLOY_DIR"
          
          echo "âœ… Deployment archive created: $(du -h deploy.tar.gz | cut -f1)"

      - name: Upload deployment archive
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: deploy.tar.gz
          retention-days: 1

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Download deployment archive
        uses: actions/download-artifact@v4
        with:
          name: deployment-package

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_PASSPHRASE: ${{ secrets.SSH_PASSPHRASE }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
        run: |
          # Create .ssh directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Validate SSH_PRIVATE_KEY
          if [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "âŒ Error: SSH_PRIVATE_KEY secret is not set"
            exit 1
          fi
          
          # Write SSH private key
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify key file
          if [ ! -s ~/.ssh/deploy_key ]; then
            echo "âŒ Error: SSH key file is empty"
            exit 1
          fi
          
          echo "âœ… SSH key file created ($(wc -l < ~/.ssh/deploy_key) lines)"
          
          # Show key format (first and last line)
          echo "ğŸ“ Key format check:"
          head -1 ~/.ssh/deploy_key
          tail -1 ~/.ssh/deploy_key
          
          # Validate key with ssh-keygen
          if ssh-keygen -l -f ~/.ssh/deploy_key 2>/dev/null; then
            echo "âœ… SSH key is valid"
            echo "ğŸ”‘ Public key fingerprint:"
            ssh-keygen -l -f ~/.ssh/deploy_key
          else
            echo "âš ï¸  Warning: Could not validate key with ssh-keygen"
            echo "ğŸ“ Key file content (first 3 lines):"
            head -3 ~/.ssh/deploy_key
          fi
          
          # Check if key is encrypted (requires passphrase)
          if grep -q "ENCRYPTED" ~/.ssh/deploy_key; then
            echo "âš ï¸  Warning: SSH key appears to be encrypted"
            if [ -z "$SSH_PASSPHRASE" ]; then
              echo "âŒ Error: Encrypted key detected but SSH_PASSPHRASE is not set"
              echo "ğŸ’¡ Solution: Either set SSH_PASSPHRASE secret or use a passphrase-less key"
              exit 1
            fi
          fi
          
          # Extract and display public key for server setup
          echo ""
          echo "ğŸ“‹ Public key (to be added to server's ~/.ssh/authorized_keys):"
          ssh-keygen -y -f ~/.ssh/deploy_key 2>/dev/null || echo "âš ï¸  Could not extract public key (may require passphrase)"
          echo ""
          
          # Add host to known_hosts
          echo "ğŸ”‘ Adding host to known_hosts..."
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts 2>/dev/null
          
          # Create SSH config for easier connection
          cat > ~/.ssh/config << EOF
          Host deploy-server
            HostName $SSH_HOST
            User ${{ secrets.SSH_USER }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking accept-new
            UserKnownHostsFile ~/.ssh/known_hosts
          EOF
          
          chmod 600 ~/.ssh/config
          
          echo "âœ… SSH configuration completed"

      - name: Test SSH Connection
        run: |
          echo "ğŸ”Œ Testing SSH connection..."
          echo "ğŸ“‹ SSH Configuration:"
          cat ~/.ssh/config
          echo ""
          echo "ğŸ”‘ SSH Key Info:"
          ls -la ~/.ssh/deploy_key
          ssh-keygen -l -f ~/.ssh/deploy_key || echo "âš ï¸  Could not read key fingerprint"
          echo ""
          echo "ğŸ” Attempting connection with verbose output..."
          ssh -vvv deploy-server "echo 'âœ… SSH connection successful'" || {
            echo ""
            echo "âŒ SSH connection test failed"
            echo "ğŸ“ Troubleshooting steps:"
            echo "1. Verify SSH_PRIVATE_KEY secret contains the full private key (including BEGIN/END lines)"
            echo "2. Ensure the corresponding public key is in ~/.ssh/authorized_keys on the server"
            echo "3. Check SSH_USER and SSH_HOST secrets are correct"
            echo "4. Verify the private key does not require a passphrase (or set SSH_PASSPHRASE secret)"
            exit 1
          }
          echo "âœ… SSH connection test passed"

      - name: Prepare deployment directory
        run: |
          echo "ğŸ“ Preparing deployment directory..."
          ssh deploy-server << 'ENDSSH'
          set -e
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          BACKUP_PATH="${DEPLOY_PATH}_backup_${TIMESTAMP}"
          
          # Create deployment directory if it doesn't exist
          mkdir -p "$DEPLOY_PATH"
          
          # Backup current deployment
          if [ -d "$DEPLOY_PATH" ] && [ "$(ls -A $DEPLOY_PATH)" ]; then
            echo "ğŸ’¾ Creating backup: $BACKUP_PATH"
            cp -r "$DEPLOY_PATH" "$BACKUP_PATH"
            echo "BACKUP_PATH=$BACKUP_PATH" >> ~/.deploy_env
          fi
          
          # Create releases directory structure
          mkdir -p "$DEPLOY_PATH/releases"
          mkdir -p "$DEPLOY_PATH/shared/storage"
          
          echo "âœ… Deployment directory prepared"
          ENDSSH

      - name: Upload and extract deployment package
        run: |
          echo "ğŸ“¤ Uploading deployment package..."
          scp deploy.tar.gz deploy-server:~/deploy.tar.gz
          
          echo "ğŸ“¦ Extracting package on server..."
          ssh deploy-server << 'ENDSSH'
          set -e
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          RELEASE_PATH="$DEPLOY_PATH/releases/$TIMESTAMP"
          
          # Create release directory
          mkdir -p "$RELEASE_PATH"
          
          # Extract deployment package
          tar -xzf ~/deploy.tar.gz -C "$RELEASE_PATH"
          rm ~/deploy.tar.gz
          
          echo "RELEASE_PATH=$RELEASE_PATH" >> ~/.deploy_env
          echo "âœ… Package extracted to: $RELEASE_PATH"
          ENDSSH

      - name: Setup shared resources and permissions
        run: |
          echo "ğŸ”— Setting up shared resources..."
          ssh deploy-server << 'ENDSSH'
          set -e
          source ~/.deploy_env
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          
          # Link shared storage
          if [ -d "$RELEASE_PATH/storage" ]; then
            rm -rf "$RELEASE_PATH/storage"
          fi
          ln -s "$DEPLOY_PATH/shared/storage" "$RELEASE_PATH/storage"
          
          # Copy .env if it exists in the main deployment path
          if [ -f "$DEPLOY_PATH/.env" ]; then
            cp "$DEPLOY_PATH/.env" "$RELEASE_PATH/.env"
          fi
          
          # Set permissions
          chmod -R 755 "$RELEASE_PATH"
          chmod -R 775 "$DEPLOY_PATH/shared/storage"
          
          echo "âœ… Shared resources configured"
          ENDSSH

      - name: Run deployment commands
        run: |
          echo "âš™ï¸  Running deployment commands..."
          ssh deploy-server << 'ENDSSH'
          set -e
          source ~/.deploy_env
          
          cd "$RELEASE_PATH"
          
          # Run Laravel deployment commands
          echo "ğŸ“ Running migrations..."
          php artisan migrate --force
          
          echo "ğŸ—‘ï¸  Clearing caches..."
          php artisan config:clear
          php artisan cache:clear
          php artisan route:clear
          php artisan view:clear
          
          echo "ğŸ“¦ Optimizing..."
          php artisan config:cache
          php artisan route:cache
          php artisan view:cache
          
          echo "âœ… Deployment commands completed"
          ENDSSH

      - name: Switch to new release
        run: |
          echo "ğŸ”„ Switching to new release..."
          ssh deploy-server << 'ENDSSH'
          set -e
          source ~/.deploy_env
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          
          # Remove old current symlink or directory
          if [ -L "$DEPLOY_PATH/current" ]; then
            rm "$DEPLOY_PATH/current"
          elif [ -d "$DEPLOY_PATH/current" ]; then
            rm -rf "$DEPLOY_PATH/current"
          fi
          
          # Create symlink to new release
          ln -s "$RELEASE_PATH" "$DEPLOY_PATH/current"
          
          echo "âœ… Switched to new release"
          ENDSSH

      - name: Cleanup old releases
        run: |
          echo "ğŸ§¹ Cleaning up old releases..."
          ssh deploy-server << 'ENDSSH'
          set -e
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          
          # Keep only the latest 5 releases
          cd "$DEPLOY_PATH/releases"
          ls -t | tail -n +6 | xargs -r rm -rf
          
          # Remove old backups (keep last 3)
          cd "$(dirname "$DEPLOY_PATH")"
          ls -td ${DEPLOY_PATH##*/}_backup_* 2>/dev/null | tail -n +4 | xargs -r rm -rf || true
          
          echo "âœ… Cleanup completed"
          ENDSSH

      - name: Verify deployment
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ğŸ“Š Deployment summary:"
          ssh deploy-server << 'ENDSSH'
          source ~/.deploy_env
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          
          echo "Current release: $(readlink $DEPLOY_PATH/current)"
          echo "Total releases: $(ls -1 $DEPLOY_PATH/releases | wc -l)"
          
          # Cleanup deploy env
          rm -f ~/.deploy_env
          ENDSSH

